/**
 * Core Message Router - Unified message routing system
 * Handles both browser.runtime.sendMessage and port-based communication
 * Cross-browser compatible with Firefox and Chrome
 */

import browser from 'webextension-polyfill';

export class CoreMessageRouter {
  constructor() {
    this.handlers = new Map();
    this.ports = new Map(); // Store active ports by context
    this.initialized = false;
    this.connectionHandlers = new Map(); // For connection-specific handlers
  }

  /**
   * Initialize the router system
   */
  async initialize() {
    if (this.initialized) return;

    // Setup runtime.onMessage listener for direct messages
    browser.runtime.onMessage.addListener.call(browser.runtime.onMessage, this.handleRuntimeMessage.bind(this));
browser.runtime.onConnect.addListener.call(browser.runtime.onConnect, this.handlePortConnection.bind(this));

    this.initialized = true;
    console.log('âœ… CoreMessageRouter initialized');
  }

  /**
   * Register a handler for specific action
   */
  registerHandler(action, handler, options = {}) {
    const handlerInfo = {
      handler,
      requiresPort: options.requiresPort || false,
      contexts: options.contexts || ['all'], // Which contexts can use this handler
      timeout: options.timeout || 30000
    };

    this.handlers.set(action, handlerInfo);
    console.log(`âœ… CoreMessageRouter: Registered handler for "${action}"`);
  }

  /**
   * Handle direct runtime messages (browser.runtime.sendMessage)
   */
  async handleRuntimeMessage(message, sender, sendResponse) {
    const messageId = `runtime-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    console.log(`[CoreMessageRouter:${messageId}] Runtime message received:`, message);
    
    try {
      const result = await this.routeMessage(message, sender, 'runtime');
      console.log(`[CoreMessageRouter:${messageId}] Runtime response:`, result);
      
      // For Firefox compatibility, ensure we return the result
      if (typeof result !== 'undefined') {
        return result;
      }
      
    } catch (error) {
      console.error(`[CoreMessageRouter:${messageId}] Runtime error:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Handle port connections
   */
  handlePortConnection(port) {
    const context = this.extractContextFromPortName(port.name);
    console.log(`[CoreMessageRouter] Port connected: ${port.name} (context: ${context})`);
    
    // Store the port
    this.ports.set(context, port);
    
    // Setup port message handlers
    port.onMessage.addListener((message) => this.handlePortMessage(message, port, context));
    port.onDisconnect.addListener(() => this.handlePortDisconnect(port, context));
    
    // Send connection acknowledgment for specific contexts
    if (['popup', 'sidepanel', 'options'].includes(context)) {
      port.postMessage({
        action: 'CONNECTION_ACK',
        context: context,
        timestamp: Date.now()
      });
    }
  }

  /**
   * Handle messages from port connections
   */
  async handlePortMessage(message, port, context) {
    const messageId = `port-${context}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    console.log(`[CoreMessageRouter:${messageId}] Port message from ${context}:`, message);
    
    try {
      // Handle connection ready handshake
      if (message.action === 'CONNECTION_READY') {
        console.log(`[CoreMessageRouter:${messageId}] Received CONNECTION_READY from ${context}. Sending ACK.`);
        port.postMessage({
          action: 'CONNECTION_ACK',
          context: context,
          messageId: message.messageId
        });
        return;
      }

      const result = await this.routeMessage(message, { tab: { id: null }, context }, 'port');
      
      // Send response back through port
      const response = {
        messageId: message.messageId,
        success: true,
        ...result
      };
      
      console.log(`[CoreMessageRouter:${messageId}] Port response:`, response);
      port.postMessage(response);
      
    } catch (error) {
      console.error(`[CoreMessageRouter:${messageId}] Port error:`, error);
      
      // Send error response through port
      port.postMessage({
        messageId: message.messageId,
        success: false,
        error: {
          message: error.message,
          type: error.type || 'UNKNOWN_ERROR',
          code: error.code || 'ROUTER_ERROR'
        }
      });
    }
  }

  /**
   * Handle port disconnection
   */
  handlePortDisconnect(port, context) {
    console.log(`[CoreMessageRouter] Port disconnected: ${port.name} (context: ${context})`);
    this.ports.delete(context);
  }

  /**
   * Route message to appropriate handler
   */
  async routeMessage(message, sender, transport) {
    const action = message.action || message.type;
    if (!action) {
      throw new Error('Message missing action or type');
    }

    const handlerInfo = this.handlers.get(action);
    if (!handlerInfo) {
      console.warn(`[CoreMessageRouter] No handler for action: ${action}`);
      return undefined;
    }

    // Check if handler requires port but message came via runtime
    if (handlerInfo.requiresPort && transport === 'runtime') {
      throw new Error(`Action ${action} requires port connection`);
    }

    // Check context permissions
    const senderContext = sender.context || this.extractContextFromSender(sender);
    if (!this.isContextAllowed(handlerInfo.contexts, senderContext)) {
      throw new Error(`Context ${senderContext} not allowed for action ${action}`);
    }

    // Execute handler with timeout
    return await Promise.race([
      handlerInfo.handler(message, sender),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error(`Handler timeout for ${action}`)), handlerInfo.timeout)
      )
    ]);
  }

  /**
   * Extract context from port name
   */
  extractContextFromPortName(portName) {
    if (portName.includes('translation-port-')) {
      return portName.replace('translation-port-', '');
    }
    if (portName.includes('popup')) return 'popup';
    if (portName.includes('sidepanel')) return 'sidepanel';
    if (portName.includes('options')) return 'options';
    if (portName.includes('content')) return 'content';
    return 'unknown';
  }

  /**
   * Extract context from sender information
   */
  extractContextFromSender(sender) {
    if (sender.tab) return 'content';
    if (sender.url?.includes('popup.html')) return 'popup';
    if (sender.url?.includes('sidepanel.html')) return 'sidepanel';
    if (sender.url?.includes('options.html')) return 'options';
    return 'background';
  }

  /**
   * Check if context is allowed for handler
   */
  isContextAllowed(allowedContexts, senderContext) {
    return allowedContexts.includes('all') || allowedContexts.includes(senderContext);
  }

  /**
   * Send message to specific context via port
   */
  async sendToContext(context, message) {
    const port = this.ports.get(context);
    if (!port) {
      throw new Error(`No active port for context: ${context}`);
    }

    const messageId = `outbound-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const messageWithId = { ...message, messageId };

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`Message timeout for context: ${context}`));
      }, 10000);

      const responseListener = (response) => {
        if (response.messageId === messageId) {
          clearTimeout(timeout);
          port.onMessage.removeListener(responseListener);
          
          if (response.success) {
            resolve(response);
          } else {
            reject(new Error(response.error?.message || 'Unknown error'));
          }
        }
      };

      port.onMessage.addListener(responseListener);
      port.postMessage(messageWithId);
    });
  }

  /**
   * Broadcast message to all connected contexts
   */
  broadcast(message, excludeContexts = []) {
    const results = [];
    
    for (const [context, port] of this.ports.entries()) {
      if (!excludeContexts.includes(context)) {
        try {
          port.postMessage(message);
          results.push({ context, success: true });
        } catch (error) {
          console.error(`Failed to broadcast to ${context}:`, error);
          results.push({ context, success: false, error: error.message });
        }
      }
    }
    
    return results;
  }

  /**
   * Get router statistics
   */
  getStats() {
    return {
      initialized: this.initialized,
      handlers: Array.from(this.handlers.keys()),
      activePorts: Array.from(this.ports.keys()),
      portCount: this.ports.size,
      handlerCount: this.handlers.size
    };
  }

  /**
   * Cleanup and shutdown
   */
  cleanup() {
    // Disconnect all ports
    for (const [context, port] of this.ports.entries()) {
      try {
        port.disconnect();
      } catch (error) {
        console.warn(`Error disconnecting port ${context}:`, error);
      }
    }
    
    this.ports.clear();
    this.handlers.clear();
    this.initialized = false;
    
    console.log('ðŸ§¹ CoreMessageRouter cleaned up');
  }
}

// Singleton instance
export const coreMessageRouter = new CoreMessageRouter();