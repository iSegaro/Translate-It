/**
 * Unified Listener Manager - Centralized system for all browser event listeners
 * Provides automatic registration, error isolation, and performance monitoring
 * Cross-browser compatible with proper lifecycle management
 */

import browser from 'webextension-polyfill';
import { BaseListener } from '../listeners/base-listener.js';

export class UnifiedListenerManager {
  constructor(coreRouter) {
    this.coreRouter = coreRouter;
    this.listeners = new Map();
    this.initialized = false;
    this.performanceMetrics = new Map();
    this.errorCounts = new Map();
  }

  /**
   * Initialize the listener manager
   */
  async initialize() {
    if (this.initialized) return;

    console.log('üéß Initializing Unified Listener Manager...');

    // Auto-register all essential listeners
    await this.registerEssentialListeners();

    this.initialized = true;
    console.log('‚úÖ Unified Listener Manager initialized');
  }

  /**
   * Register all essential browser event listeners
   */
  async registerEssentialListeners() {
    const listenerConfigs = [
      {
        name: 'runtime.onInstalled',
        eventType: 'runtime',
        eventName: 'onInstalled',
        handlers: [
          {
            name: 'installation-handler',
            fn: this.handleInstallation.bind(this)
          }
        ]
      },
      {
        name: 'runtime.onMessage',
        eventType: 'runtime',
        eventName: 'onMessage',
        handlers: [
          {
            name: 'message-router',
            fn: this.handleMessage.bind(this)
          }
        ],
        options: {
          priority: 'high',
          timeout: 30000
        }
      },
      {
        name: 'commands.onCommand',
        eventType: 'commands',
        eventName: 'onCommand',
        handlers: [
          {
            name: 'command-handler',
            fn: this.handleCommand.bind(this)
          }
        ]
      },
      {
        name: 'contextMenus.onClicked',
        eventType: 'contextMenus',
        eventName: 'onClicked',
        handlers: [
          {
            name: 'context-menu-handler',
            fn: this.handleContextMenu.bind(this)
          }
        ]
      },
      {
        name: 'notifications.onClicked',
        eventType: 'notifications',
        eventName: 'onClicked',
        handlers: [
          {
            name: 'notification-handler',
            fn: this.handleNotificationClick.bind(this)
          }
        ]
      }
    ];

    for (const config of listenerConfigs) {
      try {
        await this.createAndRegisterListener(config);
      } catch (error) {
        console.error(`‚ùå Failed to register listener ${config.name}:`, error);
        this.errorCounts.set(config.name, (this.errorCounts.get(config.name) || 0) + 1);
      }
    }
  }

  /**
   * Create and register a single listener
   */
  async createAndRegisterListener(config) {
    const { name, eventType, eventName, handlers, options = {} } = config;

    // Check if browser supports this event
    if (!this.isEventSupported(eventType, eventName)) {
      console.warn(`‚ö†Ô∏è Event ${eventType}.${eventName} not supported in this browser`);
      return;
    }

    // Create listener using BaseListener
    const listener = new (class extends BaseListener {
      constructor() {
        super(eventType, eventName, name);
      }
    })();

    // Add handlers
    handlers.forEach(handler => {
      listener.addHandler(handler.fn, handler.name);
    });

    // Initialize and register
    await listener.initialize();
    await listener.register();

    // Store listener for management
    this.listeners.set(name, {
      listener,
      config,
      options,
      registeredAt: Date.now(),
      eventCount: 0,
      errorCount: 0,
      lastEventAt: null
    });

    console.log(`‚úÖ Registered unified listener: ${name}`);
  }

  /**
   * Check if a browser event is supported
   */
  isEventSupported(eventType, eventName) {
    try {
      return browser[eventType] && browser[eventType][eventName];
    } catch {
      return false;
    }
  }

  /**
   * Handle runtime.onInstalled events
   */
  async handleInstallation(details) {
    console.log(`[UnifiedListenerManager] Installation event: ${details.reason}`);
    
    const startTime = performance.now();
    this.updateEventMetrics('runtime.onInstalled');

    try {
      // Import and run installation logic
      const { handleInstallationEvent } = await import('../handlers/installation-handler.js');
      await handleInstallationEvent(details);
      
      const duration = performance.now() - startTime;
      this.updatePerformanceMetrics('runtime.onInstalled', duration);
      
    } catch (error) {
      console.error('[UnifiedListenerManager] Installation handler error:', error);
      this.updateErrorMetrics('runtime.onInstalled');
      throw error;
    }
  }

  /**
   * Handle runtime.onMessage events - route to CoreMessageRouter
   */
  handleMessage(message, sender, sendResponse) {
    console.log('[UnifiedListenerManager] Message received, routing to CoreMessageRouter');
    console.log('[UnifiedListenerManager] sendResponse available:', typeof sendResponse, sendResponse ? 'YES' : 'NO');
    
    const startTime = performance.now();
    this.updateEventMetrics('runtime.onMessage');

    // Handle async processing with sendResponse for Firefox compatibility
    (async () => {
      try {
        console.log('[UnifiedListenerManager] Starting async processing...');
        
        // CoreMessageRouter handles the message automatically
        const result = await this.coreRouter.handleRuntimeMessage(message, sender, sendResponse);
        
        console.log('[UnifiedListenerManager] Got result from CoreMessageRouter:', result);
        
        const duration = performance.now() - startTime;
        this.updatePerformanceMetrics('runtime.onMessage', duration);
        
        // Send response back via sendResponse for Firefox
        if (sendResponse && typeof sendResponse === 'function') {
          console.log('[UnifiedListenerManager] Calling sendResponse with:', result);
          sendResponse(result);
          console.log('[UnifiedListenerManager] sendResponse called successfully');
        } else {
          console.warn('[UnifiedListenerManager] sendResponse not available or not a function');
        }
        
        // Also broadcast response for Firefox compatibility if client expects it
        if (message.expectResponse && message.messageId) {
          console.log('[UnifiedListenerManager] Broadcasting response for Firefox compatibility');
          try {
            browser.tabs.sendMessage(sender.tab?.id, {
              type: 'RESPONSE',
              originalMessageId: message.messageId,
              success: true,
              data: result
            }).catch(() => {
              // Ignore errors - tab might not exist or not have content script
              console.log('[UnifiedListenerManager] Could not broadcast to tab, trying runtime');
              // Try broadcasting via runtime for extension pages
              browser.runtime.sendMessage({
                type: 'RESPONSE',
                originalMessageId: message.messageId,
                success: true,
                data: result
              }).catch(() => {
                console.log('[UnifiedListenerManager] Broadcast failed');
              });
            });
          } catch (error) {
            console.warn('[UnifiedListenerManager] Broadcast error:', error);
          }
        }
        
      } catch (error) {
        console.error('[UnifiedListenerManager] Error handling message:', error);
        
        const duration = performance.now() - startTime;
        this.updatePerformanceMetrics('runtime.onMessage', duration);
        
        const errorResponse = { 
          success: false, 
          error: { 
            message: error.message, 
            type: error.constructor.name 
          } 
        };
        
        if (sendResponse && typeof sendResponse === 'function') {
          console.log('[UnifiedListenerManager] Calling sendResponse with error:', errorResponse);
          sendResponse(errorResponse);
        }
        
        // Also broadcast error response for Firefox compatibility
        if (message.expectResponse && message.messageId) {
          console.log('[UnifiedListenerManager] Broadcasting error response for Firefox compatibility');
          try {
            browser.tabs.sendMessage(sender.tab?.id, {
              type: 'RESPONSE',
              originalMessageId: message.messageId,
              success: false,
              error: errorResponse.error
            }).catch(() => {
              browser.runtime.sendMessage({
                type: 'RESPONSE',
                originalMessageId: message.messageId,
                success: false,
                error: errorResponse.error
              }).catch(() => {
                console.log('[UnifiedListenerManager] Error broadcast failed');
              });
            });
          } catch (broadcastError) {
            console.warn('[UnifiedListenerManager] Error broadcast failed:', broadcastError);
          }
        }
      }
    })();
    
    // Return true to indicate async response for Firefox
    console.log('[UnifiedListenerManager] Returning true for async handling');
    return true;
  }

  /**
   * Handle commands.onCommand events
   */
  async handleCommand(command, tab) {
    console.log(`[UnifiedListenerManager] Command received: ${command}`);
    
    const startTime = performance.now();
    this.updateEventMetrics('commands.onCommand');

    try {
      // Import and run command handler
      const { handleCommandEvent } = await import('../handlers/command-handler.js');
      await handleCommandEvent(command, tab);
      
      const duration = performance.now() - startTime;
      this.updatePerformanceMetrics('commands.onCommand', duration);
      
    } catch (error) {
      console.error('[UnifiedListenerManager] Command handler error:', error);
      this.updateErrorMetrics('commands.onCommand');
    }
  }

  /**
   * Handle contextMenus.onClicked events
   */
  async handleContextMenu(info, tab) {
    console.log(`[UnifiedListenerManager] Context menu clicked: ${info.menuItemId}`);
    
    const startTime = performance.now();
    this.updateEventMetrics('contextMenus.onClicked');

    try {
      // Import and run context menu handler
      const { handleContextMenuEvent } = await import('../handlers/context-menu-handler.js');
      await handleContextMenuEvent(info, tab);
      
      const duration = performance.now() - startTime;
      this.updatePerformanceMetrics('contextMenus.onClicked', duration);
      
    } catch (error) {
      console.error('[UnifiedListenerManager] Context menu handler error:', error);
      this.updateErrorMetrics('contextMenus.onClicked');
    }
  }

  /**
   * Handle notifications.onClicked events
   */
  async handleNotificationClick(notificationId) {
    console.log(`[UnifiedListenerManager] Notification clicked: ${notificationId}`);
    
    const startTime = performance.now();
    this.updateEventMetrics('notifications.onClicked');

    try {
      // Import and run notification handler
      const { handleNotificationEvent } = await import('../handlers/notification-handler.js');
      await handleNotificationEvent(notificationId);
      
      const duration = performance.now() - startTime;
      this.updatePerformanceMetrics('notifications.onClicked', duration);
      
    } catch (error) {
      console.error('[UnifiedListenerManager] Notification handler error:', error);
      this.updateErrorMetrics('notifications.onClicked');
    }
  }

  /**
   * Update event count metrics
   */
  updateEventMetrics(eventName) {
    const listenerInfo = this.listeners.get(eventName);
    if (listenerInfo) {
      listenerInfo.eventCount++;
      listenerInfo.lastEventAt = Date.now();
    }
  }

  /**
   * Update performance metrics
   */
  updatePerformanceMetrics(eventName, duration) {
    if (!this.performanceMetrics.has(eventName)) {
      this.performanceMetrics.set(eventName, {
        totalDuration: 0,
        eventCount: 0,
        averageDuration: 0,
        maxDuration: 0
      });
    }

    const metrics = this.performanceMetrics.get(eventName);
    metrics.totalDuration += duration;
    metrics.eventCount++;
    metrics.averageDuration = metrics.totalDuration / metrics.eventCount;
    metrics.maxDuration = Math.max(metrics.maxDuration, duration);
  }

  /**
   * Update error count metrics
   */
  updateErrorMetrics(eventName) {
    const listenerInfo = this.listeners.get(eventName);
    if (listenerInfo) {
      listenerInfo.errorCount++;
    }
    
    this.errorCounts.set(eventName, (this.errorCounts.get(eventName) || 0) + 1);
  }

  /**
   * Add a custom listener dynamically
   */
  async addCustomListener(name, eventType, eventName, handlerFn, options = {}) {
    if (this.listeners.has(name)) {
      throw new Error(`Listener ${name} already exists`);
    }

    const config = {
      name,
      eventType,
      eventName,
      handlers: [{ name: 'custom-handler', fn: handlerFn }],
      options
    };

    await this.createAndRegisterListener(config);
    console.log(`‚úÖ Added custom listener: ${name}`);
  }

  /**
   * Remove a listener
   */
  async removeListener(name) {
    const listenerInfo = this.listeners.get(name);
    if (!listenerInfo) {
      console.warn(`‚ö†Ô∏è Listener ${name} not found`);
      return;
    }

    try {
      await listenerInfo.listener.cleanup();
      this.listeners.delete(name);
      console.log(`üóëÔ∏è Removed listener: ${name}`);
    } catch (error) {
      console.error(`‚ùå Failed to remove listener ${name}:`, error);
    }
  }

  /**
   * Get comprehensive statistics
   */
  getStatistics() {
    const stats = {
      totalListeners: this.listeners.size,
      initialized: this.initialized,
      listeners: {},
      performance: Object.fromEntries(this.performanceMetrics),
      errors: Object.fromEntries(this.errorCounts),
      summary: {
        totalEvents: 0,
        totalErrors: 0,
        averageResponseTime: 0
      }
    };

    // Compile listener statistics
    for (const [name, info] of this.listeners.entries()) {
      stats.listeners[name] = {
        eventCount: info.eventCount,
        errorCount: info.errorCount,
        registeredAt: info.registeredAt,
        lastEventAt: info.lastEventAt,
        uptime: Date.now() - info.registeredAt,
        isHealthy: info.errorCount < info.eventCount * 0.1 // <10% error rate
      };
      
      stats.summary.totalEvents += info.eventCount;
      stats.summary.totalErrors += info.errorCount;
    }

    // Calculate average response time
    const performanceValues = Array.from(this.performanceMetrics.values());
    if (performanceValues.length > 0) {
      const totalAverage = performanceValues.reduce((sum, p) => sum + p.averageDuration, 0);
      stats.summary.averageResponseTime = totalAverage / performanceValues.length;
    }

    return stats;
  }

  /**
   * Health check for all listeners
   */
  async healthCheck() {
    const health = {
      overall: 'healthy',
      listeners: {},
      issues: []
    };

    for (const [name, info] of this.listeners.entries()) {
      const errorRate = info.eventCount > 0 ? info.errorCount / info.eventCount : 0;
      const isResponsive = info.lastEventAt ? (Date.now() - info.lastEventAt) < 300000 : true; // 5 min
      
      const listenerHealth = {
        status: 'healthy',
        errorRate: errorRate,
        isResponsive: isResponsive,
        eventCount: info.eventCount,
        errorCount: info.errorCount
      };

      if (errorRate > 0.1) {
        listenerHealth.status = 'unhealthy';
        health.issues.push(`${name}: High error rate (${(errorRate * 100).toFixed(1)}%)`);
      } else if (errorRate > 0.05) {
        listenerHealth.status = 'warning';
        health.issues.push(`${name}: Elevated error rate (${(errorRate * 100).toFixed(1)}%)`);
      }

      if (!isResponsive && info.eventCount > 0) {
        listenerHealth.status = 'unresponsive';
        health.issues.push(`${name}: No recent activity`);
      }

      health.listeners[name] = listenerHealth;
    }

    // Set overall health
    const unhealthyCount = Object.values(health.listeners).filter(l => l.status === 'unhealthy').length;
    if (unhealthyCount > 0) {
      health.overall = 'unhealthy';
    } else if (health.issues.length > 0) {
      health.overall = 'warning';
    }

    return health;
  }

  /**
   * Cleanup all listeners
   */
  async cleanup() {
    console.log('üßπ Cleaning up Unified Listener Manager...');
    
    const cleanupPromises = Array.from(this.listeners.values()).map(info => 
      info.listener.cleanup().catch(error => 
        console.warn(`Warning: Failed to cleanup listener ${info.config.name}:`, error)
      )
    );

    await Promise.allSettled(cleanupPromises);
    
    this.listeners.clear();
    this.performanceMetrics.clear();
    this.errorCounts.clear();
    this.initialized = false;
    
    console.log('‚úÖ Unified Listener Manager cleanup completed');
  }
}

// Export singleton instance
export const unifiedListenerManager = new UnifiedListenerManager();